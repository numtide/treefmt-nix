{ config
, options
, lib
, pkgs
, ...
}:
let
  inherit (lib) mkOption mkPackageOption types;

  # A new kind of option type that calls lib.getExe on derivations
  exeType = lib.mkOptionType {
    name = "exe";
    description = "Path to executable";
    check = x: lib.isString x || builtins.isPath x || lib.isDerivation x;
    merge =
      loc: defs:
      let
        res = lib.mergeOneOption loc defs;
      in
      if lib.isString res || builtins.isPath res then "${res}" else lib.getExe res;
  };

  configFormat = pkgs.formats.toml { };

  # The schema of the treefmt.toml data structure.
  configSchema = mkOption {
    default = { };
    description = "The contents of treefmt.toml";
    type = types.submodule {
      freeformType = configFormat.type;
      options = {
        global = {
          excludes = mkOption {
            description = "A global list of paths to exclude. Supports glob.";
            type = types.listOf types.str;
            default = [ ];
            example = [ "./node_modules/**" ];
          };
        };

        formatter = mkOption {
          type = types.attrsOf (
            types.submodule [
              {
                freeformType = configFormat.type;
                options = {
                  command = mkOption {
                    description = "Executable obeying the treefmt formatter spec";
                    type = exeType;
                  };

                  options = mkOption {
                    description = "List of arguments to pass to the command";
                    type = types.listOf types.str;
                    default = [ ];
                  };

                  includes = mkOption {
                    description = "List of files to include for formatting. Supports globbing.";
                    type = types.listOf types.str;
                  };

                  excludes = mkOption {
                    description = "List of files to exclude for formatting. Supports globbing. Takes precedence over the includes.";
                    type = types.listOf types.str;
                    default = [ ];
                  };
                };
              }
            ]
          );
          default = { };
          description = "Set of formatters to use";
        };
      };
      config = {
        global.excludes = lib.mkIf config.enableDefaultExcludes [
          # generated lock files i.e. yarn, cargo, nix flakes
          "*.lock"
          # Files generated by patch
          "*.patch"

          # NPM
          "package-lock.json"

          # Go
          # In theory go mod tidy could format this, but it has other side-effects beyond formatting.
          "go.mod"
          "go.sum"

          # VCS
          ".gitignore"
          ".gitmodules"
          ".hgignore"
          ".svnignore"
        ];
      };
    };

  };
in
{
  # Schema
  options = {
    # Represents the treefmt.toml config
    settings = configSchema;

    package = mkPackageOption pkgs "treefmt" { };

    projectRootFile = mkOption {
      description = ''
        File to look for to determine the root of the project in the
        build.wrapper.
      '';
      default = ".git/config";
      type = types.str;
    };

    enableDefaultExcludes = mkOption {
      description = ''
        Enable the default excludes in the treefmt configuration.
      '';
      type = types.bool;
      default = true;
    };

    # Meta attributes
    meta = {
      maintainers = lib.mkOption {
        type = lib.types.listOf lib.types.str;
        internal = true;
        default = [ ];
        example = lib.literalExpression ''[ "zimbatm" ]'';
        description = ''
          List of github users responsible for a formatter.

          This option should be defined at most once per module.
        '';
      };
    };

    # Outputs
    build = {
      devShell = mkOption {
        description = "The development shell with treefmt and its underlying programs";
        type = types.package;
        readOnly = true;
      };
      configFile = mkOption {
        description = ''
          Contains the generated config file derived from the settings.
        '';
        type = types.path;
      };
      wrapper = mkOption {
        description = ''
          The treefmt package, wrapped with the config file.
        '';
        type = types.package;
        defaultText = lib.literalMD "wrapped `treefmt` command";
        default =
          let
            code =
              if builtins.compareVersions "2.0.0-rc4" config.package.version == 1 then
                ''
                  set -euo pipefail
                  find_up() {
                    ancestors=()
                    while true; do
                      if [[ -f $1 ]]; then
                        echo "$PWD"
                        exit 0
                      fi
                      ancestors+=("$PWD")
                      if [[ $PWD == / ]] || [[ $PWD == // ]]; then
                        echo "ERROR: Unable to locate the projectRootFile ($1) in any of: ''${ancestors[*]@Q}" >&2
                        exit 1
                      fi
                      cd ..
                    done
                  }
                  tree_root=$(find_up "${config.projectRootFile}")
                  exec ${config.package}/bin/treefmt --config-file ${config.build.configFile} "$@" --tree-root "$tree_root"
                ''
              # treefmt-2.0.0-rc4 and later support the tree-root-file option
              else
                ''
                  set -euo pipefail
                  unset PRJ_ROOT
                  exec ${config.package}/bin/treefmt \
                    --config-file=${config.build.configFile} \
                    --tree-root-file=${config.projectRootFile} \
                    "$@"
                '';
            x = pkgs.writeShellScriptBin "treefmt" code;
            # used by tooling to detect if treefmt was wrapped or not
            y = pkgs.writeShellScriptBin "treefmt-nix" code;
          in
          (pkgs.symlinkJoin
            {
              name = "treefmt-nix";
              paths = [
                x
                y
              ];
            } // { meta = config.package.meta // x.meta; });
      };
      programs = mkOption {
        type = types.attrsOf types.package;
        description = ''
          Attrset of formatter programs enabled in treefmt configuration.

          The key of the attrset is the formatter name, with the value being the
          package used to do the formatting.
        '';
        defaultText = lib.literalMD "Programs used in configuration";
        default =
          pkgs.lib.concatMapAttrs
            (
              k: v:
                if (options.programs.${k}.enable.visible or true) && v.enable then
                  { "${k}" = v.package; } else { }
            )
            config.programs;
      };
      check = mkOption {
        description = ''
          Create a flake check to test that the given project tree is already
          formatted.

          Input argument is the path to the project tree (usually 'self').
        '';
        type = types.functionTo types.package;
        defaultText = lib.literalMD "Default check implementation";
        default =
          self:
          pkgs.runCommandLocal "treefmt-check"
            {
              buildInputs = [
                pkgs.git
                config.build.wrapper
              ];
              meta.description = "Check that the project tree is formatted";
            }
            ''
              set -e
              # `treefmt --fail-on-change` is broken for purs-tidy; So we must rely
              # on git to detect changes. An unintended advantage of this approach
              # is that when the check fails, it will print a helpful diff at the end.
              PRJ=$TMP/project
              cp -r ${self} $PRJ
              chmod -R a+w $PRJ
              cd $PRJ
              export HOME=$TMPDIR
              cat > $HOME/.gitconfig <<EOF
              [user]
                name = Nix
                email = nix@localhost
              [init]
                defaultBranch = main
              EOF
              git init
              git add .
              git commit -m init --quiet
              export LANG=${if pkgs.stdenv.isDarwin then "en_US.UTF-8" else "C.UTF-8"}
              export LC_ALL=${if pkgs.stdenv.isDarwin then "en_US.UTF-8" else "C.UTF-8"}
              treefmt --version
              treefmt --no-cache
              git status
              git --no-pager diff --exit-code
              touch $out
            '';
      };
    };
  };

  # Config
  config.build = {
    configFile = configFormat.generate "treefmt.toml" config.settings;
    devShell = pkgs.mkShell {
      nativeBuildInputs = [ config.build.wrapper ] ++ (lib.attrValues config.build.programs);
    };
  };
}
