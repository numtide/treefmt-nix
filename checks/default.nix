{ pkgs, treefmt-nix, ... }:
let
  inherit (pkgs) lib;

  join = lib.concatStringsSep;

  toConfig =
    name:
    treefmt-nix.mkConfigFile pkgs {
      programs.${name}.enable = true;
    };

  # Helper to get meta attributes for a specific formatter
  getFormatterMeta =
    name:
    let
      # Find the module file for this formatter
      moduleFile = ../programs + "/${name}.nix";
      # Import it with minimal context to extract meta
      moduleImport = import moduleFile {
        inherit (pkgs) lib;
        inherit (treefmt-nix) mkFormatterModule;
        # Provide dummy values for modules that need them
        config = { };
        options = { };
        pkgs = pkgs;
      };
    in
    moduleImport.meta or { };

  # Check if a platform is supported by a formatter
  isPlatformSupported =
    platform: meta:
    let
      supportedPlatforms = meta.platforms or null;
      brokenPlatforms = meta.brokenPlatforms or [ ];
    in
    (supportedPlatforms == null || lib.elem platform supportedPlatforms)
    && !(lib.elem platform brokenPlatforms);

  # Check if a formatter should be included based on its meta attributes
  isFormatterUsable =
    name:
    let
      meta = getFormatterMeta name;
      isBroken = meta.broken or false;
      currentPlatform = pkgs.stdenv.hostPlatform.system;
    in
    !isBroken && isPlatformSupported currentPlatform meta;

  # Standard platforms that examples should work on
  standardPlatforms = [
    "x86_64-linux"
    "aarch64-linux"
    "x86_64-darwin"
    "aarch64-darwin"
  ];

  # Check if a formatter should skip example generation
  shouldSkipExample =
    name:
    let
      meta = getFormatterMeta name;
      explicitSkip = meta.skipExample or false;
      availableOnAllStandardPlatforms = lib.all (
        platform: isPlatformSupported platform meta
      ) standardPlatforms;
    in
    explicitSkip || !availableOnAllStandardPlatforms;

  # Filter formatters for program configs
  usableFormatterNames = lib.filter isFormatterUsable treefmt-nix.programs.names;

  programConfigs = lib.listToAttrs (
    map (name: {
      name = "formatter-${name}";
      value = toConfig name;
    }) usableFormatterNames
  );

  examples =
    let
      configs =
        lib.mapAttrs
          (name: value: ''
            {
              echo "# Example generated by ../examples.sh"
              sed -n '/^$/q;p' ${value} | sed 's|\(command = "\).*/\([^"]\+"\)|\1\2|' | sed 's|/nix/store/.*-||'
            } > "$out/${name}.toml"
          '')
          (
            lib.filterAttrs (
              n: _:
              # Filter out formatters to skip in example generation
              !shouldSkipExample (lib.removePrefix "formatter-" n)
            ) programConfigs
          );
    in
    pkgs.runCommand "examples" { } ''
      mkdir $out

      ${join "\n" (lib.attrValues configs)}
    '';

  treefmtEval = treefmt-nix.evalModule pkgs ../treefmt.nix;

  treefmtDocEval = treefmt-nix.evalModule stubPkgs ../treefmt.nix;

  stubPkgs =
    lib.mapAttrs (
      k: _:
      throw "The module documentation must not depend on pkgs attributes such as ${lib.strings.escapeNixIdentifier k}"
    ) pkgs
    // {
      _type = "pkgs";
      inherit lib;
      # Formats is ok and supported upstream too
      inherit (pkgs) formats;
    };

  self = {
    empty-config = treefmt-nix.mkConfigFile pkgs { };

    simple-wrapper = treefmt-nix.mkWrapper pkgs {
      projectRootFile = "flake.nix";
    };

    # Check if the examples folder needs to be updated
    examples =
      pkgs.runCommand "test-examples"
        {
          passthru.examples = examples;
        }
        ''
          if ! diff -r ${../examples} ${examples}; then
            echo "The generated ./examples folder is out of sync"
            echo "Run ./examples.sh to fix the issue"
            exit 1
          fi
          touch $out
        '';

    # Check that the repo is formatted
    self-formatting = treefmtEval.config.build.check ../.;

    # Expose the current wrapper
    self-wrapper = treefmtEval.config.build.wrapper;

    # Check that the docs render properly
    module-docs = (pkgs.nixosOptionsDoc { options = treefmtDocEval.options; }).optionsCommonMark;
  } // programConfigs;
in
self
